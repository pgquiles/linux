/*
 * AMLOGIC lcd external driver.
 *
 * Communication protocol:
 * MIPI 
 *
 */

#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/slab.h>
#include <linux/jiffies.h> 
#include <linux/i2c.h>
#include <linux/i2c-aml.h>
#include <linux/miscdevice.h>
#include <linux/mutex.h>
#include <linux/mm.h>
#include <linux/device.h>
#include <linux/fs.h>
#include <linux/delay.h>
#include <linux/sysctl.h>
#include <asm/uaccess.h>
#include <mach/pinmux.h>
#include <mach/gpio.h>
#include <linux/amlogic/vout/aml_lcd_extern.h>

static struct lcd_extern_config_t *lcd_ext_config = NULL;

//#define LCD_EXT_DEBUG_INFO
#ifdef LCD_EXT_DEBUG_INFO
#define DBG_PRINT(...)		printk(__VA_ARGS__)
#else
#define DBG_PRINT(...)
#endif

#define LCD_EXTERN_NAME			"lcd_mipi_N070ICN"

static unsigned char mipi_init_table[] = {
    5,0xFF,0xAA,0x55,0xA5,0x80, //========== Internal setting ==========

    3,0x6F,0x11,0x00, //MIPI related Timing Setting
    3,0xF7,0x20,0x00,

    2,0x6F,0x06,      //Improve ESD option
    2,0xF7,0xA0,
    2,0x6F,0x19,
    2,0xF7,0x12,

    2,0x6F,0x08,     //Vcom floating
    2,0xFA,0x40,
    2,0x6F,0x11,
    2,0xF3,0x01,

    6,0xF0,0x55,0xAA,0x52,0x08,0x00, //========== page0 relative ==========

    3,0xB1,0x68,0x01, //Set WXGA resolution

    2,0xB6,0x08,      //Set source output hold time

    2,0x6F,0x02,      //EQ control function
    2,0xB8,0x08,

    3,0xBB,0x54,0x44, //Set bias current for GOP and SOP

    3,0xBC,0x05,0x05, //Inversion setting

    2,0xC7,0x01,      //zigzag setting

    6,0xBD,0x02,0xB0,0x0C,0x0A,0x00, //DSP Timing Settings update for BIST

    6,0xF0,0x55,0xAA,0x52,0x08,0x01, //========== page1 relative ==========

    3,0xB0,0x05,0x05,                // Setting AVDD, AVEE clamp
    3,0xB1,0x05,0x05,

    3,0xBC,0x3A,0x01,                // VGMP, VGMN, VGSP, VGSN setting
    3,0xBD,0x3E,0x01,

    2,0xCA,0x00,                    // gate signal control

    2,0xC0,0x04,                    // power IC control

    2,0xBE,0x80,      //vcom    -1.88V

    3,0xB3,0x28,0x28, // Setting VGH=15V, VGL=-11V
    3,0xB4,0x12,0x12,

    3,0xB9,0x34,0x34, // power control for VGH, VGL
    3,0xBA,0x24,0x24,

    6,0xF0,0x55,0xAA,0x52,0x08,0x02, //========== page2 relative ==========

    2,0xEE,0x02,                     //Gamma control register control
    5,0xEF,0x09,0x06,0x15,0x18,      //Gradient Control for Gamma Voltage


    17,0xB0,0x00,0x00,0x00,0x9D,0x00,0xAE,0x00,0xC1,0x00,0xD6,0x00,0xE9,0x01,0x09,0x01,0x3E,
    17,0xB1,0x01,0x64,0x01,0xA5,0x01,0xDC,0x02,0x2F,0x02,0x64,0x02,0x65,0x02,0x92,0x02,0xBA,
    17,0xB2,0x02,0xD1,0x02,0xFB,0x03,0x19,0x03,0x46,0x03,0x61,0x03,0x90,0x03,0xA8,0x03,0xCF,
    5,0xB3,0x03,0xE8,0x03,0xFF,

    7,0xBC,0x00,0x00,0x00,0x08,0x00,0x18, //========== GOA relative ==========
    2,0x6F,0x06,                          //PAGE6 : GOUT Mapping, VGLO select
    7,0xBC,0x00,0x27,0x00,0x32,0x00,0x49,
    2,0x6F,0x0C,
    5,0xBC,0x00,0x5C,0x00,0x83,
    7,0xBD,0x00,0xAF,0x00,0xF3,0x01,0x2A, ////////////////////////////
    2,0x6F,0x06,
    7,0xBD,0x01,0x84,0x01,0xCA,0x01,0xCD,
    2,0x6F,0x0C,
    5,0xBD,0x02,0x0E,0x02,0x65,
    7,0xBE,0x02,0x98,0x02,0xD4,0x03,0x00,
    2,0x6F,0x06,
    7,0xBE,0x03,0x37,0x03,0x5F,0x03,0x8D,
    2,0x6F,0x0C,
    5,0xBE,0x03,0xA4,0x03,0xBF,
    5,0xBF,0x03,0xE8,0x03,0xFF,

    6,0xF0,0x55,0xAA,0x52,0x08,0x06,
    3,0xB0,0x00,0x17,
    3,0xB1,0x16,0x15,
    3,0xB2,0x14,0x13,
    3,0xB3,0x12,0x11,
    3,0xB4,0x10,0x2D,
    3,0xB5,0x01,0x08,
    3,0xB6,0x09,0x31,
    3,0xB7,0x31,0x31,
    3,0xB8,0x31,0x31,
    3,0xB9,0x31,0x31,
    3,0xBA,0x31,0x31,
    3,0xBB,0x31,0x31,
    3,0xBC,0x31,0x31,
    3,0xBD,0x31,0x09,
    3,0xBE,0x08,0x01,
    3,0xBF,0x2D,0x10,
    3,0xC0,0x11,0x12,
    3,0xC1,0x13,0x14,
    3,0xC2,0x15,0x16,
    3,0xC3,0x17,0x00,
    3,0xE5,0x31,0x31,
    3,0xC4,0x00,0x17,
    3,0xC5,0x16,0x15,
    3,0xC6,0x14,0x13,
    3,0xC7,0x12,0x11,
    3,0xC8,0x10,0x2D,
    3,0xC9,0x01,0x08,
    3,0xCA,0x09,0x31,
    3,0xCB,0x31,0x31,
    3,0xCC,0x31,0x31,
    3,0xCD,0x31,0x31,
    3,0xCE,0x31,0x31,
    3,0xCF,0x31,0x31,
    3,0xD0,0x31,0x31,
    3,0xD1,0x31,0x09,
    3,0xD2,0x08,0x01,
    3,0xD3,0x2D,0x10,
    3,0xD4,0x11,0x12,
    3,0xD5,0x13,0x14,
    3,0xD6,0x15,0x16,
    3,0xD7,0x17,0x00,
    3,0xE6,0x31,0x31,
    6,0xD8,0x00,0x00,0x00,0x00,0x00, //VGL level select;
    6,0xD9,0x00,0x00,0x00,0x00,0x00,
    2,0xE7,0x00,

    6,0xF0,0x55,0xAA,0x52,0x08,0x03, //gate timing control
    3,0xB0,0x20,0x00,
    3,0xB1,0x20,0x00,
    6,0xB2,0x05,0x00,0x68,0x00,0x00,
    6,0xB6,0x05,0x00,0x68,0x00,0x00,
    6,0xBA,0x53,0x00,0x68,0x00,0x00,
    6,0xBB,0x53,0x00,0x68,0x00,0x00,
    2,0xC4,0x40,

    3,0xB0,0x01,0x01, //gate CLK EQ
    3,0xB1,0x01,0x01, //gate STV EQ

    6,0xF0,0x55,0xAA,0x52,0x08,0x05,
    3,0xB0,0x17,0x06,
    2,0xB8,0x00,
    6,0xBD,0x03,0x01,0x01,0x00,0x01,
    3,0xB1,0x17,0x06,
    3,0xB9,0x00,0x01,
    3,0xB2,0x17,0x06,
    3,0xBA,0x00,0x01,
    3,0xB3,0x17,0x06,
    3,0xBB,0x0A,0x00,
    3,0xB4,0x17,0x06,
    3,0xB5,0x17,0x06,
    3,0xB6,0x14,0x03,
    3,0xB7,0x00,0x00,
    3,0xBC,0x02,0x01,
    2,0xC0,0x05,
    2,0xC4,0xA5,
    3,0xC8,0x03,0x30,
    3,0xC9,0x03,0x51,
    6,0xD1,0x03,0x00,0x00,0x00,0x10,
    6,0xD2,0x03,0x00,0x00,0x00,0x10,
    2,0xE5,0x02,
    2,0xE6,0x02,
    2,0xE7,0x02,
    2,0xE9,0x02,
    2,0xED,0x33,

    2,0x6F,0x11, //reload setting
    2,0xF3,0x01,
    0xff,0xff,   //ending flag
};

static int lcd_extern_driver_update(void)
{
    struct aml_lcd_extern_driver_t* lcd_ext;

    lcd_ext = aml_lcd_extern_get_driver();
    if (lcd_ext) {
        lcd_ext->type       = lcd_ext_config->type;
        lcd_ext->name       = lcd_ext_config->name;
        lcd_ext->init_on_cmd_8 = &mipi_init_table[0];
    }
    else {
        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
    }

    return 0;
}

static int aml_N070ICN_probe(struct platform_device *pdev)
{
    int i = 0;

    if (lcd_extern_driver_check()) {
        return -1;
    }
    if (lcd_ext_config == NULL)
        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
    if (lcd_ext_config == NULL) {
        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
        return -1;
    }

    pdev->dev.platform_data = lcd_ext_config;

    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
        goto lcd_extern_probe_failed;
    }
    lcd_extern_driver_update();

    printk("%s probe ok\n", LCD_EXTERN_NAME);
    return 0;

lcd_extern_probe_failed:
    if (lcd_ext_config)
        kfree(lcd_ext_config);
    return -1;
}

static int aml_N070ICN_remove(struct platform_device *pdev)
{
    if (pdev->dev.platform_data)
        kfree (pdev->dev.platform_data);
    return 0;
}

#ifdef CONFIG_USE_OF
static const struct of_device_id aml_N070ICN_dt_match[]={
    {
        .compatible = "amlogic,lcd_mipi_N070ICN",
    },
    {},
};
#else
#define aml_N070ICN_dt_match NULL
#endif

static struct platform_driver aml_N070ICN_driver = {
    .probe  = aml_N070ICN_probe,
    .remove = aml_N070ICN_remove,
    .driver = {
        .name  = LCD_EXTERN_NAME,
        .owner = THIS_MODULE,
#ifdef CONFIG_USE_OF
        .of_match_table = aml_N070ICN_dt_match,
#endif
    },
};

static int __init aml_N070ICN_init(void)
{
    int ret;
    DBG_PRINT("%s\n", __FUNCTION__);

    ret = platform_driver_register(&aml_N070ICN_driver);
    if (ret) {
        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
        return -ENODEV;
    }

    return ret;
}

static void __exit aml_N070ICN_exit(void)
{
    platform_driver_unregister(&aml_N070ICN_driver);
}

//late_initcall(aml_N070ICN_init);
module_init(aml_N070ICN_init);
module_exit(aml_N070ICN_exit);

MODULE_AUTHOR("AMLOGIC");
MODULE_DESCRIPTION("LCD Extern driver for N070ICN");
MODULE_LICENSE("GPL");
